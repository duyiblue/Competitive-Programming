## CF1188A2 Add on a Tree: Revolution

[题目链接](https://codeforces.com/contest/1188/problem/A2)

请注意重要条件：所给局面中，边权都是偶数，且互不相同。

---

**引理**：有解当且仅当不存在度数为 $2$ 的点。

必要性是很显然的。因为如果存在度数为 $2$ 的点，考虑它连接的两条边，每次操作，这两条边要么都不被经过，要么一起被经过。所以最终局面下，这两条边的边权一定相同。又因为题目所给局面里边权互不相同，矛盾了。所以：若有解，一定不存在度数为 $2$ 的点。

充分性，我们通过构造来证明。

首先，对于任意叶子节点 $u$、任意其他节点 $v$、以及任意偶数 $x$，可以实现一种基本操作是：给 $(u, v)$ 路径上所有边边权加上 $x$，且不改变其他边的边权。具体做法是：

- 如果 $v$ 也是叶子节点，一步操作即可实现。
- 如果 $v$ 不是叶子节点，那么 $v$ 度数至少为 $3$。不妨以 $v$ 为根。考虑 $v$ 除了包含 $u$ 的儿子外的另外两个儿子，记为 $s_1, s_2$。从 $s_1, s_2$ 的子树里各取一个叶子，记为 $l_1, l_2$。那么可以通过如下三次操作，实现我们想要的效果：
  - 对 $(l_1, u)$ 的路径加上 $\frac{x}{2}$。
  - 对 $(l_2, u)$ 的路径加上 $\frac{x}{2}$。
  - 对 $(l_1, l_2)$ 的路径加上 $-\frac{x}{2}$。

有了上述基本操作后，可以这样构造出本题的解法：取一个度数为 $1$ 的节点为根，记为 $r$。从 $r$ 出发 dfs。具体来说，我们实现一个函数：$\text{solve}(u)$，它的任务是，通过操作使得 $u$ 子树内所有边边权都变为 $0$，且可以任意改变 $u$ 到根路径上的边权，但不允许改变 $u$ 子树外其他边的边权。同时，要保证任意时刻所有边边权均为偶数。

考虑 $u$ 的每个儿子 $v$。先调用 $\text{solve}(v)$，那么此时 $v$ 的子树已经被解决了，之后我们不会再去碰它。考虑 $(u, v)$ 这条边此时的边权，记为 $x$（$x$ 一定是偶数）。我们通过上述基本操作，令 $r$ 到 $v$ 路径上所有边边权加上 $-x$。这样使得 $(u, v)$ 的边权变为 $0$，且 $u$ 到根路径上的边权仍然都是偶数。

把上述的【将所有边边权变为 $0$ 的】的过程反过来（加变成减，减变成加），就是答案了。

朴素的实现方法，就是在操作时暴力更改所有祖先的边权，时间复杂度 $\mathcal{O}(n^2)$。也可以用树上差分来优化，时间复杂度 $\mathcal{O}(n)$。

[参考代码-在CF查看](https://codeforces.com/contest/1188/submission/110713049)

---

**总结**：

一开始不知道有解的条件，我们就先蒙一个显然的**必要条件**。然后在满足这个条件的前提下，尝试去构造解法。如果构造出来了，说明该条件也是充分的。

首先构造出一个**基本操作**，它像是我们的砖头，我们用它来盖大房子。

树上的问题，要注意到树本身特有的、“递归式”的结构，以子树作为天然的子问题，递归地解决。

**归类**：树，递归。

**难度**：中。